<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Orberita</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Comfortaa:wght@400;700&family=Impact&family=Lexend:wght@400;700&family=Merriweather:wght@400;700&family=Caveat:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            height: 100vh;
            display: flex;
            font-family: Arial, sans-serif;
        }

        .left-section {
            width: 50%;
            background-color: #f5f5f5;
            transition: width 0.3s ease;
            position: relative;
            padding-bottom: 60px;
        }

        .left-section.expanded {
            width: 100%;
        }

        .right-section {
            width: 50%;
            padding: 20px;
            display: flex;
            transition: width 0.3s ease;
            position: relative;
            flex-direction: column;
        }

        .copy-button {
            position: absolute;
            top: 30px;
            right: 30px;
            background-color: white;
            border: 1px solid #ddd;
            padding: 8px 16px;
            cursor: pointer;
            font-size: 14px;
            color: black;
            z-index: 10;
            border-radius: 4px;
            font-weight: 500;
        }

        .copy-button:hover {
            background-color: #f0f0f0;
        }

        .copy-button:active {
            background-color: #e0e0e0;
        }

        .right-section.hidden {
            width: 0;
            padding: 0;
            overflow: hidden;
        }

        .right-section.hidden .copy-button {
            display: none;
        }

        .toggle-button {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: white;
            border: 1px solid #ddd;
            padding: 10px 15px;
            cursor: pointer;
            font-size: 18px;
            color: black;
            z-index: 10;
            border-radius: 4px;
        }

        .toggle-button:hover {
            background-color: #f0f0f0;
        }

        .text-button {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: white;
            border: 1px solid #ddd;
            padding: 10px 15px;
            cursor: pointer;
            font-size: 18px;
            color: black;
            z-index: 10;
            border-radius: 4px;
        }

        .text-button:hover {
            background-color: #f0f0f0;
        }

        .bottom-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 60px;
            background-color: white;
            border-top: 1px solid #ddd;
            display: none;
            align-items: center;
            padding: 0 20px;
            gap: 10px;
            z-index: 10;
        }

        .bottom-bar.visible {
            display: flex;
        }

        .color-picker-button {
            background-color: white;
            border: 1px solid #ddd;
            padding: 8px;
            cursor: pointer;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 44px;
            height: 44px;
        }

        .color-picker-button:hover {
            background-color: #f0f0f0;
        }

        .color-circle {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background-color: #000000;
            border: 2px solid #ddd;
        }

        .color-input {
            display: none;
        }

        .toggle-gradient-button {
            background-color: white;
            border: 1px solid #ddd;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 18px;
            font-weight: bold;
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .toggle-gradient-button:hover {
            background-color: #f0f0f0;
        }

        .gradient-controls {
            display: none;
            align-items: center;
            gap: 10px;
        }

        .gradient-controls.visible {
            display: flex;
        }

        .gradient-type-select {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: white;
            cursor: pointer;
            font-size: 14px;
        }

        .gradient-direction-button {
            background-color: white;
            border: 1px solid #ddd;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 18px;
            font-weight: bold;
            width: 44px;
            height: 44px;
            display: none;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .gradient-controls.visible .gradient-direction-button {
            display: flex;
        }

        .gradient-direction-button:hover {
            background-color: #f0f0f0;
        }

        .compass-popup {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            width: 120px;
            height: 120px;
            background-color: #e0e0e0;
            border: 2px solid #999;
            border-radius: 12px;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .compass-popup.visible {
            display: flex;
        }

        .compass-circle {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background-color: #f5f5f5;
            border: 2px solid #666;
            position: relative;
            pointer-events: none;
        }

        .compass-line {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 2px;
            height: 45px;
            background-color: #333;
            transform-origin: bottom center;
            transform: translate(-50%, -100%) rotate(90deg);
            cursor: grab;
            pointer-events: auto;
            z-index: 10;
        }

        .compass-line:active {
            cursor: grabbing;
        }

        .compass-tip {
            position: absolute;
            top: -6px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-bottom: 8px solid #333;
            pointer-events: none;
        }

        .font-select {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: white;
            cursor: pointer;
            font-size: 14px;
        }

        .toggle-outline-button {
            background-color: white;
            border: 1px solid #ddd;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 18px;
            font-weight: bold;
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .toggle-outline-button:hover {
            background-color: #f0f0f0;
        }

        .outline-controls {
            display: none;
            align-items: center;
            gap: 10px;
        }

        .outline-controls.visible {
            display: flex;
        }

        .toggle-outline-button {
            background-color: white;
            border: 1px solid #ddd;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 18px;
            font-weight: bold;
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .toggle-outline-button:hover {
            background-color: #f0f0f0;
        }

        .outline-controls {
            display: none;
            align-items: center;
            gap: 10px;
        }

        .outline-controls.visible {
            display: flex;
        }

        .transparency-slider {
            width: 100px;
            height: 6px;
            border-radius: 3px;
            background: linear-gradient(to right, transparent, #000);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .transparency-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4a90e2;
            border: 2px solid white;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .transparency-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4a90e2;
            border: 2px solid white;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .toggle-shadow-button {
            background-color: white;
            border: 1px solid #ddd;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 18px;
            font-weight: bold;
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .toggle-shadow-button:hover {
            background-color: #f0f0f0;
        }

        .toggle-bold-button {
            background-color: white;
            border: 1px solid #ddd;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 18px;
            font-weight: bold;
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .toggle-bold-button:hover {
            background-color: #f0f0f0;
        }

        .toggle-bold-button.active {
            background-color: #4a90e2;
            color: white;
        }

        .shadow-edit-button {
            background-color: white;
            border: 1px solid #ddd;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 14px;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .shadow-edit-button.visible {
            display: flex;
        }

        .shadow-edit-button:hover {
            background-color: #f0f0f0;
        }

        .shadow-editor-popup {
            position: absolute;
            bottom: 60px;
            right: 20px;
            width: 200px;
            background-color: #e0e0e0;
            border: 2px solid #999;
            border-radius: 12px;
            padding: 15px;
            display: none;
            flex-direction: column;
            gap: 10px;
            z-index: 1000;
        }

        .shadow-editor-popup.visible {
            display: flex;
        }

        .shadow-editor-label {
            font-size: 14px;
            font-weight: bold;
            color: #333;
        }

        .shadow-slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: linear-gradient(to right, transparent, #000);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .shadow-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4a90e2;
            border: 2px solid white;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .shadow-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4a90e2;
            border: 2px solid white;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .shadow-compass {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background-color: #f5f5f5;
            border: 2px solid #666;
            position: relative;
            margin: 0 auto;
            pointer-events: none;
        }

        .shadow-compass-line {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 2px;
            height: 45px;
            background-color: #333;
            transform-origin: bottom center;
            transform: translate(-50%, -100%) rotate(135deg);
            cursor: grab;
            pointer-events: auto;
            z-index: 10;
        }

        .shadow-compass-line:active {
            cursor: grabbing;
        }

        .shadow-compass-tip {
            position: absolute;
            top: -6px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-bottom: 8px solid #333;
            pointer-events: none;
        }

        .draggable-text {
            position: absolute;
            padding: 5px 10px;
            cursor: move;
            user-select: none;
            border: 2px solid transparent;
            font-size: 16px;
            color: #000000;
            display: inline-block;
            font-weight: normal;
            font-family: Arial;
            width: fit-content;
            max-width: 100%;
        }

        .draggable-text.selected {
            border: 2px solid #007bff !important;
            background-color: rgba(0, 123, 255, 0.1) !important;
        }

        .draggable-text.editing {
            cursor: text;
            user-select: text;
        }

        .resize-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background-color: #4a90e2;
            border: 2px solid white;
            display: none;
            z-index: 100;
            border-radius: 2px;
            user-select: none;
            opacity: 1 !important;
        }

        .draggable-text.selected .resize-handle {
            display: block;
            pointer-events: auto;
        }

        .draggable-text.editing .resize-handle {
            display: block;
            pointer-events: none;
        }

        .resize-handle.top-left {
            top: -6px;
            left: -6px;
            cursor: nwse-resize;
        }

        .resize-handle.top-right {
            top: -6px;
            right: -6px;
            cursor: nesw-resize;
        }

        .resize-handle.bottom-left {
            bottom: -6px;
            left: -6px;
            cursor: nesw-resize;
        }

        .resize-handle.bottom-right {
            bottom: -6px;
            right: -6px;
            cursor: nwse-resize;
        }

        textarea {
            width: 100%;
            height: 100%;
            padding: 20px;
            font-size: 16px;
            border: 1px solid #ddd;
            resize: none;
            font-family: Arial, sans-serif;
        }

        textarea::placeholder {
            color: #999;
        }
    </style>
</head>
<body>
    <div class="left-section" id="leftSection">
        <button class="toggle-button" id="toggleButton" onclick="togglePanel()">&lt;</button>
        <button class="text-button" id="textButton" onclick="createTextBox()">T</button>
        <div class="bottom-bar" id="bottomBar">
            <button class="color-picker-button" id="colorPickerButton" onclick="openColorPicker()">
                <div class="color-circle" id="colorCircle"></div>
            </button>
            <input type="color" class="color-input" id="colorInput" value="#000000">
            
            <button class="toggle-gradient-button" id="toggleGradientButton" onclick="toggleGradient()">+</button>
            
            <div class="gradient-controls" id="gradientControls">
                <button class="color-picker-button" onclick="openGradientColorPicker()">
                    <div class="color-circle" id="gradientColorCircle" style="background-color: #ff0000;"></div>
                </button>
                <input type="color" class="color-input" id="gradientColorInput" value="#ff0000">
                
                <select class="gradient-type-select" id="gradientTypeSelect" onchange="updateGradient()">
                    <option value="linear">linear</option>
                    <option value="radial">radial</option>
                </select>
                
                <button class="gradient-direction-button" id="gradientDirectionButton" onclick="toggleCompass(event)">
                    D
                    <div class="compass-popup" id="compassPopup">
                        <div class="compass-circle">
                            <div class="compass-line" id="compassLine">
                                <div class="compass-tip"></div>
                            </div>
                        </div>
                    </div>
                </button>
            </div>
            
            <select class="font-select" id="fontSelect" onchange="updateFont()">
                <option value="Arial">Arial</option>
                <option value="Comfortaa">Comfortaa</option>
                <option value="Impact">Impact</option>
                <option value="Lexend">Lexend</option>
                <option value="Merriweather">Merriweather</option>
                <option value="Caveat">Caveat</option>
            </select>
            
            <button class="toggle-outline-button" id="toggleOutlineButton" onclick="toggleOutline()">O</button>
            
            <div class="outline-controls" id="outlineControls">
                <button class="color-picker-button" onclick="openOutlineColorPicker()">
                    <div class="color-circle" id="outlineColorCircle" style="background-color: #000000;"></div>
                </button>
                <input type="color" class="color-input" id="outlineColorInput" value="#000000">
            </div>
            
            <input type="range" class="transparency-slider" id="transparencySlider" min="0" max="1" step="0.01" value="1">
            
            <button class="toggle-shadow-button" id="toggleShadowButton" onclick="toggleShadow()">S</button>
            
            <button class="toggle-bold-button" id="toggleBoldButton" onclick="toggleBold()">B</button>
            
            <button class="shadow-edit-button" id="shadowEditButton" onclick="toggleShadowEditor(event)">edit</button>
            
            <div class="shadow-editor-popup" id="shadowEditorPopup">
                <div class="shadow-editor-label">Opacity</div>
                <input type="range" class="shadow-slider" id="shadowOpacitySlider" min="0" max="1" step="0.01" value="1">
                
                <div class="shadow-editor-label">Distance</div>
                <input type="range" class="shadow-slider" id="shadowDistanceSlider" min="0" max="50" step="1" value="5">
                
                <div class="shadow-compass">
                    <div class="shadow-compass-line" id="shadowCompassLine">
                        <div class="shadow-compass-tip"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="right-section" id="rightSection">
        <button class="copy-button" onclick="copyCode()">Copy</button>
        <textarea placeholder="Write or design"></textarea>
    </div>

    <script>
        let selectedTextBox = null;
        let isDragging = false;
        let isResizing = false;
        let currentResizeHandle = null;
        let offsetX = 0;
        let offsetY = 0;
        let startX = 0;
        let startY = 0;
        let startWidth = 0;
        let startHeight = 0;
        let startFontSize = 16;
        let gradientEnabled = false;
        let isUpdatingFromCode = false;

        function togglePanel() {
            const leftSection = document.getElementById('leftSection');
            const rightSection = document.getElementById('rightSection');
            const toggleButton = document.getElementById('toggleButton');
            
            if (rightSection.classList.contains('hidden')) {
                rightSection.classList.remove('hidden');
                leftSection.classList.remove('expanded');
                toggleButton.innerHTML = '&lt;';
            } else {
                rightSection.classList.add('hidden');
                leftSection.classList.add('expanded');
                toggleButton.innerHTML = '&gt;';
            }
        }

        function toggleGradient() {
            const toggleButton = document.getElementById('toggleGradientButton');
            const gradientControls = document.getElementById('gradientControls');
            
            gradientEnabled = !gradientEnabled;
            
            if (gradientEnabled) {
                toggleButton.textContent = '-';
                gradientControls.classList.add('visible');
                if (selectedTextBox) {
                    applyGradient();
                }
            } else {
                toggleButton.textContent = '+';
                gradientControls.classList.remove('visible');
                if (selectedTextBox) {
                    removeGradient();
                }
            }
        }

        function applyGradient() {
            if (!selectedTextBox) return;
            
            const color1 = document.getElementById('colorInput').value;
            const color2 = document.getElementById('gradientColorInput').value;
            const gradientType = document.getElementById('gradientTypeSelect').value;
            const opacity = parseFloat(selectedTextBox.dataset.opacity || '1');
            
            selectedTextBox.dataset.gradientEnabled = 'true';
            selectedTextBox.dataset.gradientColor1 = color1;
            selectedTextBox.dataset.gradientColor2 = color2;
            selectedTextBox.dataset.gradientType = gradientType;
            selectedTextBox.dataset.gradientAngle = gradientAngle;
            
            // Remove any existing color
            selectedTextBox.style.color = '';
            
            // Convert colors to rgba with opacity
            const rgba1 = hexToRgba(color1, opacity);
            const rgba2 = hexToRgba(color2, opacity);
            
            // Set gradient background
            if (gradientType === 'linear') {
                selectedTextBox.style.background = `linear-gradient(${gradientAngle}deg, ${rgba1}, ${rgba2})`;
            } else {
                // Use farthest-corner to ensure gradient is always visible
                selectedTextBox.style.background = `radial-gradient(circle farthest-corner at center, ${rgba1} 0%, ${rgba2} 100%)`;
            }
            
            // Set clip properties
            selectedTextBox.style.webkitBackgroundClip = 'text';
            selectedTextBox.style.webkitTextFillColor = 'transparent';
            selectedTextBox.style.backgroundClip = 'text';
            
            updateHTMLCode();
        }

        function removeGradient() {
            if (!selectedTextBox) return;
            
            selectedTextBox.dataset.gradientEnabled = 'false';
            
            // Remove gradient properties
            selectedTextBox.style.background = '';
            selectedTextBox.style.webkitBackgroundClip = '';
            selectedTextBox.style.webkitTextFillColor = '';
            selectedTextBox.style.backgroundClip = '';
            
            // Restore solid color
            const color = selectedTextBox.dataset.solidColor || '#000000';
            selectedTextBox.style.color = color;
            
            updateHTMLCode();
        }

        function updateGradient() {
            if (gradientEnabled && selectedTextBox) {
                applyGradient();
            }
        }

        function updateFont() {
            if (!selectedTextBox) return;
            
            const fontSelect = document.getElementById('fontSelect');
            const fontFamily = fontSelect.value;
            
            selectedTextBox.style.fontFamily = fontFamily;
            selectedTextBox.dataset.fontFamily = fontFamily;
            
            updateHTMLCode();
        }

        let outlineEnabled = false;
        let gradientAngle = 90; // Default angle for linear gradient (left to right)
        let isDraggingCompass = false;
        let shadowEnabled = false;
        let shadowAngle = 135; // Default shadow angle (bottom-right)
        let shadowDistance = 5;
        let shadowOpacity = 1;
        let isDraggingShadowCompass = false;

        function toggleShadow() {
            const toggleButton = document.getElementById('toggleShadowButton');
            const editButton = document.getElementById('shadowEditButton');
            
            shadowEnabled = !shadowEnabled;
            
            if (shadowEnabled) {
                toggleButton.textContent = '-';
                editButton.classList.add('visible');
                if (selectedTextBox) {
                    applyShadow();
                }
            } else {
                toggleButton.textContent = 'S';
                editButton.classList.remove('visible');
                document.getElementById('shadowEditorPopup').classList.remove('visible');
                if (selectedTextBox) {
                    removeShadow();
                }
            }
        }

        function toggleShadowEditor(e) {
            if (e) e.stopPropagation();
            const popup = document.getElementById('shadowEditorPopup');
            popup.classList.toggle('visible');
        }

        function toggleBold() {
            if (!selectedTextBox) return;
            
            const isBold = selectedTextBox.dataset.isBold === 'true';
            const toggleButton = document.getElementById('toggleBoldButton');
            
            if (isBold) {
                // Remove bold
                selectedTextBox.style.fontWeight = 'normal';
                selectedTextBox.dataset.isBold = 'false';
                toggleButton.classList.remove('active');
            } else {
                // Apply bold
                selectedTextBox.style.fontWeight = 'bold';
                selectedTextBox.dataset.isBold = 'true';
                toggleButton.classList.add('active');
            }
            
            updateHTMLCode();
        }

        function applyShadow() {
            if (!selectedTextBox) return;
            
            const angle = shadowAngle;
            const distance = shadowDistance;
            const opacity = shadowOpacity;
            
            // Convert angle to x,y offset
            const radians = (angle - 90) * (Math.PI / 180);
            const x = Math.cos(radians) * distance;
            const y = Math.sin(radians) * distance;
            
            selectedTextBox.dataset.shadowEnabled = 'true';
            selectedTextBox.dataset.shadowAngle = angle;
            selectedTextBox.dataset.shadowDistance = distance;
            selectedTextBox.dataset.shadowOpacity = opacity;
            
            selectedTextBox.style.textShadow = `${x.toFixed(1)}px ${y.toFixed(1)}px 3px rgba(0, 0, 0, ${opacity})`;
            
            updateHTMLCode();
        }

        function removeShadow() {
            if (!selectedTextBox) return;
            
            selectedTextBox.dataset.shadowEnabled = 'false';
            selectedTextBox.style.textShadow = '';
            
            updateHTMLCode();
        }

        // Close shadow edit popup when clicking outside
        document.addEventListener('click', function(e) {
            const popup = document.getElementById('shadowEditorPopup');
            const editButton = document.getElementById('shadowEditButton');
            const compassLine = document.getElementById('shadowCompassLine');
            
            if (!editButton.contains(e.target) && 
                !popup.contains(e.target) &&
                popup.classList.contains('visible')) {
                popup.classList.remove('visible');
            }
        });

        function toggleCompass(e) {
            if (e) e.stopPropagation();
            const compassPopup = document.getElementById('compassPopup');
            compassPopup.classList.toggle('visible');
        }

        // Close compass when clicking outside
        document.addEventListener('click', function(e) {
            const compassPopup = document.getElementById('compassPopup');
            const directionButton = document.getElementById('gradientDirectionButton');
            const compassLine = document.getElementById('compassLine');
            
            if (!directionButton.contains(e.target) && 
                !compassLine.contains(e.target) && 
                compassPopup.classList.contains('visible')) {
                compassPopup.classList.remove('visible');
            }
        });

        // Compass line dragging - set up after DOM loads
        window.addEventListener('load', function() {
            const compassLine = document.getElementById('compassLine');
            const compassCircle = compassLine.parentElement;

            compassLine.addEventListener('mousedown', function(e) {
                e.preventDefault();
                e.stopPropagation();
                isDraggingCompass = true;
                compassLine.style.cursor = 'grabbing';
            });

            document.addEventListener('mousemove', function(e) {
                if (!isDraggingCompass) return;
                
                const rect = compassCircle.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                const deltaX = e.clientX - centerX;
                const deltaY = e.clientY - centerY;
                
                // Calculate angle in degrees (0 = right, 90 = down, 180 = left, 270 = up)
                let angle = Math.atan2(deltaY, deltaX) * (180 / Math.PI);
                
                // Convert to CSS gradient angle (0 = up, 90 = right, 180 = down, 270 = left)
                angle = angle + 90;
                if (angle < 0) angle += 360;
                
                gradientAngle = Math.round(angle);
                
                // Update compass line rotation
                compassLine.style.transform = `translate(-50%, -100%) rotate(${gradientAngle}deg)`;
                
                // Update gradient
                if (selectedTextBox && gradientEnabled) {
                    applyGradient();
                }
            });

            document.addEventListener('mouseup', function() {
                if (isDraggingCompass) {
                    isDraggingCompass = false;
                    compassLine.style.cursor = 'grab';
                }
            });

            // Shadow compass dragging
            const shadowCompassLine = document.getElementById('shadowCompassLine');
            const shadowCompass = shadowCompassLine.parentElement;

            shadowCompassLine.addEventListener('mousedown', function(e) {
                e.preventDefault();
                e.stopPropagation();
                isDraggingShadowCompass = true;
                shadowCompassLine.style.cursor = 'grabbing';
            });

            document.addEventListener('mousemove', function(e) {
                if (!isDraggingShadowCompass) return;
                
                const rect = shadowCompass.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                const deltaX = e.clientX - centerX;
                const deltaY = e.clientY - centerY;
                
                let angle = Math.atan2(deltaY, deltaX) * (180 / Math.PI);
                angle = angle + 90;
                if (angle < 0) angle += 360;
                
                shadowAngle = Math.round(angle);
                shadowCompassLine.style.transform = `translate(-50%, -100%) rotate(${shadowAngle}deg)`;
                
                if (selectedTextBox && shadowEnabled) {
                    applyShadow();
                }
            });

            document.addEventListener('mouseup', function() {
                if (isDraggingShadowCompass) {
                    isDraggingShadowCompass = false;
                    shadowCompassLine.style.cursor = 'grab';
                }
            });

            // Shadow opacity slider
            document.getElementById('shadowOpacitySlider').addEventListener('input', function(e) {
                shadowOpacity = parseFloat(e.target.value);
                if (selectedTextBox && shadowEnabled) {
                    applyShadow();
                }
            });

            // Shadow distance slider
            document.getElementById('shadowDistanceSlider').addEventListener('input', function(e) {
                shadowDistance = parseFloat(e.target.value);
                if (selectedTextBox && shadowEnabled) {
                    applyShadow();
                }
            });
        });

        function toggleOutline() {
            const toggleButton = document.getElementById('toggleOutlineButton');
            const outlineControls = document.getElementById('outlineControls');
            
            outlineEnabled = !outlineEnabled;
            
            if (outlineEnabled) {
                toggleButton.textContent = '-';
                outlineControls.classList.add('visible');
                if (selectedTextBox) {
                    applyOutline();
                }
            } else {
                toggleButton.textContent = 'O';
                outlineControls.classList.remove('visible');
                if (selectedTextBox) {
                    removeOutline();
                }
            }
        }

        function applyOutline() {
            if (!selectedTextBox) return;
            
            const outlineColor = document.getElementById('outlineColorInput').value;
            
            selectedTextBox.dataset.outlineEnabled = 'true';
            selectedTextBox.dataset.outlineColor = outlineColor;
            
            selectedTextBox.style.webkitTextStroke = `2px ${outlineColor}`;
            
            updateHTMLCode();
        }

        function removeOutline() {
            if (!selectedTextBox) return;
            
            selectedTextBox.dataset.outlineEnabled = 'false';
            selectedTextBox.style.webkitTextStroke = '';
            
            updateHTMLCode();
        }

        function openOutlineColorPicker() {
            const outlineColorInput = document.getElementById('outlineColorInput');
            outlineColorInput.click();
        }

        // Listen for outline color changes
        document.getElementById('outlineColorInput').addEventListener('input', function(e) {
            const newColor = e.target.value;
            if (selectedTextBox && outlineEnabled && selectedTextBox.dataset.outlineEnabled === 'true') {
                selectedTextBox.dataset.outlineColor = newColor;
                selectedTextBox.style.webkitTextStroke = `2px ${newColor}`;
                updateOutlineColorCircle();
                updateHTMLCode();
            }
        });

        function updateOutlineColorCircle() {
            const outlineColorCircle = document.getElementById('outlineColorCircle');
            if (selectedTextBox && selectedTextBox.dataset.outlineEnabled === 'true') {
                const outlineColor = selectedTextBox.dataset.outlineColor || '#000000';
                outlineColorCircle.style.backgroundColor = outlineColor;
            } else {
                outlineColorCircle.style.backgroundColor = '#000000';
            }
        }

        // Listen for transparency slider changes
        document.getElementById('transparencySlider').addEventListener('input', function(e) {
            const opacity = parseFloat(e.target.value);
            if (selectedTextBox) {
                selectedTextBox.dataset.opacity = opacity;
                
                // Apply opacity to the text color/gradient, not the box
                const hasGradient = selectedTextBox.dataset.gradientEnabled === 'true';
                
                if (hasGradient) {
                    // Reapply gradient with new opacity
                    applyGradient();
                } else {
                    // Apply opacity to solid color
                    const solidColor = selectedTextBox.dataset.solidColor || '#000000';
                    const rgbaColor = hexToRgba(solidColor, opacity);
                    selectedTextBox.style.color = rgbaColor;
                }
                
                updateHTMLCode();
            }
        });

        // Helper function to convert hex to rgba
        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        // Helper function for HTML generation (returns rgba string)
        function hexToRgbaString(hex, alphaStr) {
            const alpha = parseFloat(alphaStr);
            if (alpha === 1) {
                return hex; // Return hex if fully opaque
            }
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        // Copy code to clipboard
        function copyCode() {
            const textarea = document.querySelector('textarea');
            textarea.select();
            textarea.setSelectionRange(0, 99999); // For mobile devices
            
            navigator.clipboard.writeText(textarea.value).then(function() {
                // Visual feedback
                const copyButton = document.querySelector('.copy-button');
                const originalText = copyButton.textContent;
                copyButton.textContent = 'Copied!';
                copyButton.style.backgroundColor = '#4CAF50';
                copyButton.style.color = 'white';
                
                setTimeout(function() {
                    copyButton.textContent = originalText;
                    copyButton.style.backgroundColor = '';
                    copyButton.style.color = '';
                }, 2000);
            }).catch(function(err) {
                console.error('Failed to copy:', err);
            });
        }

        function openColorPicker() {
            const colorInput = document.getElementById('colorInput');
            colorInput.click();
        }

        function openGradientColorPicker() {
            const gradientColorInput = document.getElementById('gradientColorInput');
            gradientColorInput.click();
        }

        function updateColorCircle() {
            const colorCircle = document.getElementById('colorCircle');
            const gradientColorCircle = document.getElementById('gradientColorCircle');
            
            if (selectedTextBox) {
                const color1 = selectedTextBox.dataset.gradientColor1 || selectedTextBox.dataset.solidColor || '#000000';
                const color2 = selectedTextBox.dataset.gradientColor2 || '#ff0000';
                colorCircle.style.backgroundColor = color1;
                gradientColorCircle.style.backgroundColor = color2;
            } else {
                colorCircle.style.backgroundColor = '#000000';
                gradientColorCircle.style.backgroundColor = '#ff0000';
            }
        }

        function showBottomBar() {
            const bottomBar = document.getElementById('bottomBar');
            if (selectedTextBox) {
                bottomBar.classList.add('visible');
            } else {
                bottomBar.classList.remove('visible');
            }
        }

        // Listen for color changes
        document.getElementById('colorInput').addEventListener('input', function(e) {
            const newColor = e.target.value;
            if (selectedTextBox) {
                selectedTextBox.dataset.solidColor = newColor;
                selectedTextBox.dataset.gradientColor1 = newColor;
                
                const opacity = parseFloat(selectedTextBox.dataset.opacity || '1');
                
                if (gradientEnabled && selectedTextBox.dataset.gradientEnabled === 'true') {
                    applyGradient();
                } else {
                    // Apply color with opacity
                    const rgbaColor = hexToRgba(newColor, opacity);
                    selectedTextBox.style.color = rgbaColor;
                    // Clear any gradient properties
                    selectedTextBox.style.background = '';
                    selectedTextBox.style.webkitBackgroundClip = '';
                    selectedTextBox.style.webkitTextFillColor = '';
                    selectedTextBox.style.backgroundClip = '';
                }
                updateColorCircle();
                updateHTMLCode();
            }
        });

        function updateVisualFromCode() {
            const textarea = document.querySelector('textarea');
            const htmlCode = textarea.value;
            
            // Parse the HTML to extract styles and text
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlCode, 'text/html');
            
            // Get all paragraph elements
            const paragraphs = doc.querySelectorAll('p');
            const leftSection = document.getElementById('leftSection');
            const existingTextBoxes = leftSection.querySelectorAll('.draggable-text');
            
            // Update existing text boxes or create new ones
            paragraphs.forEach((p, index) => {
                const className = p.className;
                const textContent = p.textContent.trim();
                
                if (!textContent) return;
                
                // Find the corresponding style
                const styleTag = doc.querySelector('style');
                if (!styleTag) return;
                
                const styleText = styleTag.textContent;
                const classMatch = styleText.match(new RegExp(`\\.${className}\\s*{([^}]*)}`, 's'));
                
                if (!classMatch) return;
                
                const styles = classMatch[1];
                
                // Extract individual style properties
                const fontSizeMatch = styles.match(/font-size:\s*(\d+)px/);
                const topMatch = styles.match(/top:\s*(\d+)px/);
                const leftMatch = styles.match(/left:\s*(\d+)px/);
                const colorMatch = styles.match(/color:\s*([^;]+);/);
                const backgroundMatch = styles.match(/background:\s*([^;]+);/);
                const webkitBgClipMatch = styles.match(/-webkit-background-clip:\s*text/);
                const webkitTextFillMatch = styles.match(/-webkit-text-fill-color:\s*transparent/);
                const fontFamilyMatch = styles.match(/font-family:\s*([^;]+);/);
                const outlineMatch = styles.match(/-webkit-text-stroke:\s*2px\s*([^;]+);/);
                const opacityMatch = styles.match(/opacity:\s*([0-9.]+);/);
                const shadowMatch = styles.match(/text-shadow:\s*([^;]+);/);
                const fontWeightMatch = styles.match(/font-weight:\s*(bold|normal);/);
                
                let textBox;
                if (existingTextBoxes[index]) {
                    textBox = existingTextBoxes[index];
                } else {
                    // Create new text box if it doesn't exist
                    textBox = document.createElement('div');
                    textBox.className = 'draggable-text';
                    textBox.contentEditable = false;
                    textBox.style.fontWeight = 'normal';
                    textBox.dataset.baseFontSize = '16';
                    textBox.dataset.solidColor = '#000000';
                    textBox.dataset.gradientEnabled = 'false';
                    textBox.dataset.gradientColor1 = '#000000';
                    textBox.dataset.gradientColor2 = '#ff0000';
                    textBox.dataset.gradientType = 'linear';
                    textBox.dataset.gradientAngle = '90';
                    textBox.dataset.fontFamily = 'Arial';
                    textBox.dataset.outlineEnabled = 'false';
                    textBox.dataset.outlineColor = '#000000';
                    textBox.dataset.opacity = '1';
                    textBox.dataset.shadowEnabled = 'false';
                    textBox.dataset.shadowAngle = '135';
                    textBox.dataset.shadowDistance = '5';
                    textBox.dataset.shadowOpacity = '1';
                    textBox.dataset.isBold = 'false';
                    
                    // Add resize handles
                    const handles = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];
                    handles.forEach(position => {
                        const handle = document.createElement('div');
                        handle.className = `resize-handle ${position}`;
                        handle.contentEditable = 'false';
                        handle.addEventListener('mousedown', function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            startResize(e, textBox, position);
                        });
                        textBox.appendChild(handle);
                    });
                    
                    // Add event listeners
                    textBox.addEventListener('mousedown', function(e) {
                        if (!textBox.classList.contains('editing') && !e.target.classList.contains('resize-handle')) {
                            e.preventDefault();
                            selectTextBox(textBox);
                            isDragging = true;
                            offsetX = e.clientX - textBox.offsetLeft;
                            offsetY = e.clientY - textBox.offsetTop;
                        }
                    });
                    
                    textBox.addEventListener('dblclick', function(e) {
                        if (!e.target.classList.contains('resize-handle')) {
                            e.preventDefault();
                            textBox.classList.add('editing');
                            textBox.contentEditable = true;
                            
                            // Reset to auto width when editing starts
                            textBox.style.width = 'auto';
                            textBox.style.height = 'auto';
                            
                            textBox.focus();
                            
                            const range = document.createRange();
                            const selection = window.getSelection();
                            selection.removeAllRanges();
                            
                            const firstNode = Array.from(textBox.childNodes).find(node => 
                                !node.classList || !node.classList.contains('resize-handle')
                            );
                            
                            const lastNode = Array.from(textBox.childNodes).reverse().find(node => 
                                !node.classList || !node.classList.contains('resize-handle')
                            );
                            
                            if (firstNode && lastNode) {
                                range.setStartBefore(firstNode);
                                range.setEndAfter(lastNode);
                                selection.addRange(range);
                            }
                        }
                    });
                    
                    textBox.addEventListener('keydown', function(e) {
                        if (e.key === 'Enter' && textBox.classList.contains('editing')) {
                            e.preventDefault();
                            textBox.blur();
                        }
                    });
                    
                    textBox.addEventListener('input', function() {
                        // Reset width to auto to fit text as user types
                        textBox.style.width = 'auto';
                        textBox.style.height = 'auto';
                        updateHTMLCode();
                    });
                    
                    textBox.addEventListener('blur', function() {
                        textBox.classList.remove('editing');
                        textBox.contentEditable = false;
                        
                        // Get text content excluding resize handles
                        const textContent = Array.from(textBox.childNodes)
                            .filter(node => !node.classList || !node.classList.contains('resize-handle'))
                            .map(node => node.textContent)
                            .join('');
                        
                        // Ensure resize handles still exist
                        const existingHandles = textBox.querySelectorAll('.resize-handle');
                        if (existingHandles.length < 4) {
                            existingHandles.forEach(h => h.remove());
                            const handlePositions = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];
                            handlePositions.forEach(position => {
                                const handle = document.createElement('div');
                                handle.className = `resize-handle ${position}`;
                                handle.contentEditable = 'false';
                                handle.addEventListener('mousedown', function(e) {
                                    e.preventDefault();
                                    e.stopPropagation();
                                    startResize(e, textBox, position);
                                });
                                textBox.appendChild(handle);
                            });
                        }
                        
                        if (textContent.trim() === '') {
                            Array.from(textBox.childNodes).forEach(node => {
                                if (!node.classList || !node.classList.contains('resize-handle')) {
                                    node.remove();
                                }
                            });
                            const handles = textBox.querySelectorAll('.resize-handle');
                            if (handles.length > 0) {
                                textBox.insertBefore(document.createTextNode('Double-click to edit'), handles[0]);
                            }
                        }
                        
                        // Reset width to auto to fit text
                        textBox.style.width = 'auto';
                        textBox.style.height = 'auto';
                        
                        updateHTMLCode();
                    });
                    
                    leftSection.appendChild(textBox);
                }
                
                // Update text content (preserve resize handles)
                const handles = textBox.querySelectorAll('.resize-handle');
                // Remove all non-handle nodes
                Array.from(textBox.childNodes).forEach(node => {
                    if (!node.classList || !node.classList.contains('resize-handle')) {
                        node.remove();
                    }
                });
                // Add text before the first handle
                if (handles.length > 0) {
                    textBox.insertBefore(document.createTextNode(textContent), handles[0]);
                } else {
                    textBox.textContent = textContent;
                }
                
                // Apply styles
                if (fontSizeMatch) {
                    textBox.style.fontSize = fontSizeMatch[1] + 'px';
                }
                if (topMatch) {
                    textBox.style.top = topMatch[1] + 'px';
                }
                if (leftMatch) {
                    textBox.style.left = leftMatch[1] + 'px';
                }
                if (fontFamilyMatch) {
                    const fontFamily = fontFamilyMatch[1].trim();
                    textBox.style.fontFamily = fontFamily;
                    textBox.dataset.fontFamily = fontFamily;
                }
                if (outlineMatch) {
                    const outlineColor = outlineMatch[1].trim();
                    textBox.style.webkitTextStroke = `2px ${outlineColor}`;
                    textBox.dataset.outlineEnabled = 'true';
                    textBox.dataset.outlineColor = outlineColor;
                } else {
                    textBox.style.webkitTextStroke = '';
                    textBox.dataset.outlineEnabled = 'false';
                }
                if (opacityMatch) {
                    const opacity = opacityMatch[1];
                    textBox.dataset.opacity = opacity;
                } else {
                    textBox.dataset.opacity = '1';
                }
                if (shadowMatch) {
                    const shadowValue = shadowMatch[1].trim();
                    // Parse shadow: "5px 5px 3px rgba(0, 0, 0, 1)"
                    const shadowParts = shadowValue.match(/([-0-9.]+)px\s+([-0-9.]+)px\s+\d+px\s+rgba\([^,]+,[^,]+,[^,]+,\s*([0-9.]+)\)/);
                    if (shadowParts) {
                        const x = parseFloat(shadowParts[1]);
                        const y = parseFloat(shadowParts[2]);
                        const opacity = parseFloat(shadowParts[3]);
                        
                        // Calculate angle and distance from x,y
                        const distance = Math.sqrt(x * x + y * y);
                        let angle = Math.atan2(y, x) * (180 / Math.PI) + 90;
                        if (angle < 0) angle += 360;
                        
                        textBox.dataset.shadowEnabled = 'true';
                        textBox.dataset.shadowAngle = Math.round(angle).toString();
                        textBox.dataset.shadowDistance = distance.toFixed(1);
                        textBox.dataset.shadowOpacity = opacity.toString();
                        textBox.style.textShadow = shadowValue;
                    }
                } else {
                    textBox.dataset.shadowEnabled = 'false';
                    textBox.style.textShadow = '';
                }
                if (fontWeightMatch) {
                    const fontWeight = fontWeightMatch[1];
                    if (fontWeight === 'bold') {
                        textBox.style.fontWeight = 'bold';
                        textBox.dataset.isBold = 'true';
                    } else {
                        textBox.style.fontWeight = 'normal';
                        textBox.dataset.isBold = 'false';
                    }
                } else {
                    textBox.style.fontWeight = 'normal';
                    textBox.dataset.isBold = 'false';
                }
                
                // Check if gradient or solid color
                if (backgroundMatch && webkitBgClipMatch && webkitTextFillMatch) {
                    // It's a gradient
                    const background = backgroundMatch[1].trim();
                    
                    // Parse gradient
                    let gradientType = 'linear';
                    let colors = [];
                    let angle = 90;
                    let opacity = '1';
                    
                    if (background.includes('linear-gradient')) {
                        gradientType = 'linear';
                        const colorMatches = background.match(/#[0-9a-fA-F]{6}|#[0-9a-fA-F]{3}|rgba?\([^)]+\)/g);
                        if (colorMatches) colors = colorMatches;
                        
                        // Parse angle
                        const angleMatch = background.match(/(\d+)deg/);
                        if (angleMatch) {
                            angle = parseInt(angleMatch[1]);
                        }
                    } else if (background.includes('radial-gradient')) {
                        gradientType = 'radial';
                        const colorMatches = background.match(/#[0-9a-fA-F]{6}|#[0-9a-fA-F]{3}|rgba?\([^)]+\)/g);
                        if (colorMatches) colors = colorMatches;
                    }
                    
                    // Parse colors and extract opacity if present
                    let hexColor1 = '#000000';
                    let hexColor2 = '#ff0000';
                    
                    if (colors[0]) {
                        const rgba1Match = colors[0].match(/rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([0-9.]+)\s*\)/);
                        if (rgba1Match) {
                            const r = rgba1Match[1];
                            const g = rgba1Match[2];
                            const b = rgba1Match[3];
                            opacity = rgba1Match[4];
                            hexColor1 = '#' + 
                                parseInt(r).toString(16).padStart(2, '0') +
                                parseInt(g).toString(16).padStart(2, '0') +
                                parseInt(b).toString(16).padStart(2, '0');
                        } else {
                            hexColor1 = colors[0];
                        }
                    }
                    
                    if (colors[1]) {
                        const rgba2Match = colors[1].match(/rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([0-9.]+)\s*\)/);
                        if (rgba2Match) {
                            const r = rgba2Match[1];
                            const g = rgba2Match[2];
                            const b = rgba2Match[3];
                            hexColor2 = '#' + 
                                parseInt(r).toString(16).padStart(2, '0') +
                                parseInt(g).toString(16).padStart(2, '0') +
                                parseInt(b).toString(16).padStart(2, '0');
                        } else {
                            hexColor2 = colors[1];
                        }
                    }
                    
                    textBox.dataset.gradientEnabled = 'true';
                    textBox.dataset.gradientType = gradientType;
                    textBox.dataset.gradientColor1 = hexColor1;
                    textBox.dataset.gradientColor2 = hexColor2;
                    textBox.dataset.gradientAngle = angle.toString();
                    textBox.dataset.opacity = opacity;
                    textBox.dataset.solidColor = hexColor1;
                    
                    // Apply gradient visually with the original colors (which include alpha if present)
                    if (gradientType === 'linear') {
                        textBox.style.background = `linear-gradient(${angle}deg, ${colors[0] || '#000000'}, ${colors[1] || '#ff0000'})`;
                    } else {
                        // Use the new radial format for consistency
                        textBox.style.background = `radial-gradient(circle farthest-corner at center, ${colors[0] || '#000000'} 0%, ${colors[1] || '#ff0000'} 100%)`;
                    }
                    textBox.style.webkitBackgroundClip = 'text';
                    textBox.style.webkitTextFillColor = 'transparent';
                    textBox.style.backgroundClip = 'text';
                    textBox.style.color = '';
                } else if (colorMatch) {
                    // It's a solid color
                    const color = colorMatch[1].trim();
                    
                    // Check if it's rgba and extract opacity
                    const rgbaMatch = color.match(/rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([0-9.]+)\s*\)/);
                    if (rgbaMatch) {
                        const r = rgbaMatch[1];
                        const g = rgbaMatch[2];
                        const b = rgbaMatch[3];
                        const alpha = rgbaMatch[4];
                        
                        // Convert back to hex for storage
                        const hex = '#' + 
                            parseInt(r).toString(16).padStart(2, '0') +
                            parseInt(g).toString(16).padStart(2, '0') +
                            parseInt(b).toString(16).padStart(2, '0');
                        
                        textBox.dataset.solidColor = hex;
                        textBox.dataset.gradientColor1 = hex;
                        textBox.dataset.opacity = alpha;
                    } else {
                        // Plain hex or color name
                        textBox.dataset.solidColor = color;
                        textBox.dataset.gradientColor1 = color;
                        textBox.dataset.opacity = '1';
                    }
                    
                    textBox.dataset.gradientEnabled = 'false';
                    textBox.style.color = color; // Apply the color as-is (with alpha if present)
                    textBox.style.background = '';
                    textBox.style.webkitBackgroundClip = '';
                    textBox.style.webkitTextFillColor = '';
                    textBox.style.backgroundClip = '';
                }
            });
            
            // Remove extra text boxes if there are more than in the code
            for (let i = paragraphs.length; i < existingTextBoxes.length; i++) {
                existingTextBoxes[i].remove();
            }
            
            // Update selected text box UI if it exists
            if (selectedTextBox) {
                updateColorCircle();
            }
        }

        // Listen for gradient color changes
        document.getElementById('gradientColorInput').addEventListener('input', function(e) {
            const newColor = e.target.value;
            if (selectedTextBox) {
                selectedTextBox.dataset.gradientColor2 = newColor;
                if (gradientEnabled && selectedTextBox.dataset.gradientEnabled === 'true') {
                    applyGradient();
                }
                updateColorCircle();
                updateHTMLCode();
            }
        });

        // Listen for changes in the textarea
        let codeUpdateTimeout;
        document.querySelector('textarea').addEventListener('input', function() {
            if (isUpdatingFromCode) return; // Prevent loop
            
            clearTimeout(codeUpdateTimeout);
            codeUpdateTimeout = setTimeout(() => {
                updateVisualFromCode();
            }, 500); // Debounce for 500ms
        });

        function updateHTMLCode() {
            isUpdatingFromCode = true;
            
            const leftSection = document.getElementById('leftSection');
            const textBoxes = leftSection.querySelectorAll('.draggable-text');
            const textarea = document.querySelector('textarea');
            
            let htmlContent = `<!DOCTYPE html>
<html>
<head>
    <title>First page</title>
    <style>
`;
            
            // Add style for each text box
            textBoxes.forEach((textBox, index) => {
                // Get text content excluding resize handles
                const textContent = Array.from(textBox.childNodes)
                    .filter(node => !node.classList || !node.classList.contains('resize-handle'))
                    .map(node => node.textContent)
                    .join('');
                
                const text = textContent.trim();
                
                if (text && text !== 'Double-click to edit') {
                    const fontSize = parseInt(textBox.style.fontSize) || 16;
                    const top = parseInt(textBox.style.top) || 0;
                    const left = parseInt(textBox.style.left) || 0;
                    
                    const hasGradient = textBox.dataset.gradientEnabled === 'true';
                    const fontFamily = textBox.dataset.fontFamily || 'Arial';
                    const hasOutline = textBox.dataset.outlineEnabled === 'true';
                    const outlineColor = textBox.dataset.outlineColor || '#000000';
                    const opacity = textBox.dataset.opacity || '1';
                    const hasShadow = textBox.dataset.shadowEnabled === 'true';
                    const isBold = textBox.dataset.isBold === 'true';
                    
                    htmlContent += `        .text${index + 1} {
            font-size: ${fontSize}px;
            position: absolute;
            top: ${top}px;
            left: ${left}px;
            font-family: ${fontFamily};
`;
                    
                    if (isBold) {
                        htmlContent += `            font-weight: bold;
`;
                    }
                    
                    if (hasOutline) {
                        htmlContent += `            -webkit-text-stroke: 2px ${outlineColor};
`;
                    }
                    
                    if (hasShadow) {
                        const shadowAngle = parseFloat(textBox.dataset.shadowAngle) || 135;
                        const shadowDistance = parseFloat(textBox.dataset.shadowDistance) || 5;
                        const shadowOpacity = parseFloat(textBox.dataset.shadowOpacity) || 1;
                        
                        const radians = (shadowAngle - 90) * (Math.PI / 180);
                        const x = Math.cos(radians) * shadowDistance;
                        const y = Math.sin(radians) * shadowDistance;
                        
                        htmlContent += `            text-shadow: ${x.toFixed(1)}px ${y.toFixed(1)}px 3px rgba(0, 0, 0, ${shadowOpacity});
`;
                    }
                    
                    if (hasGradient) {
                        const color1 = textBox.dataset.gradientColor1 || '#000000';
                        const color2 = textBox.dataset.gradientColor2 || '#000000';
                        const gradientType = textBox.dataset.gradientType || 'linear';
                        const angle = textBox.dataset.gradientAngle || '90';
                        
                        // Convert colors to rgba with opacity
                        const rgba1 = hexToRgbaString(color1, opacity);
                        const rgba2 = hexToRgbaString(color2, opacity);
                        
                        if (gradientType === 'linear') {
                            htmlContent += `            background: linear-gradient(${angle}deg, ${rgba1}, ${rgba2});
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
`;
                        } else {
                            htmlContent += `            background: radial-gradient(circle farthest-corner at center, ${rgba1} 0%, ${rgba2} 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
`;
                        }
                    } else {
                        const color = textBox.dataset.solidColor || '#000000';
                        // Convert to rgba with opacity
                        const rgba = hexToRgbaString(color, opacity);
                        htmlContent += `            color: ${rgba};
`;
                    }
                    
                    htmlContent += `        }
`;
                }
            });
            
            htmlContent += `    </style>
</head>
<body>
`;
            
            // Add paragraph elements
            let textIndex = 1;
            textBoxes.forEach((textBox) => {
                // Get text content excluding resize handles
                const textContent = Array.from(textBox.childNodes)
                    .filter(node => !node.classList || !node.classList.contains('resize-handle'))
                    .map(node => node.textContent)
                    .join('');
                
                const text = textContent.trim();
                
                if (text && text !== 'Double-click to edit') {
                    htmlContent += `    <p class="text${textIndex}">\n        ${text}\n    </p>\n`;
                    textIndex++;
                }
            });
            
            htmlContent += `</body>
</html>`;
            
            textarea.value = htmlContent;
            
            setTimeout(() => {
                isUpdatingFromCode = false;
            }, 100);
        }

        function createTextBox() {
            const leftSection = document.getElementById('leftSection');
            const textBox = document.createElement('div');
            textBox.className = 'draggable-text';
            textBox.contentEditable = false;
            textBox.textContent = 'Double-click to edit';
            textBox.style.left = '100px';
            textBox.style.top = '100px';
            textBox.style.width = 'auto';
            textBox.style.height = 'auto';
            textBox.style.fontSize = '16px';
            textBox.style.color = '#000000';
            textBox.style.fontFamily = 'Arial';
            textBox.style.fontWeight = 'normal';
            textBox.dataset.baseFontSize = '16';
            textBox.dataset.solidColor = '#000000';
            textBox.dataset.gradientEnabled = 'false';
            textBox.dataset.gradientColor1 = '#000000';
            textBox.dataset.gradientColor2 = '#ff0000';
            textBox.dataset.gradientType = 'linear';
            textBox.dataset.gradientAngle = '90';
            textBox.dataset.fontFamily = 'Arial';
            textBox.dataset.outlineEnabled = 'false';
            textBox.dataset.outlineColor = '#000000';
            textBox.dataset.opacity = '1';
            textBox.dataset.shadowEnabled = 'false';
            textBox.dataset.shadowAngle = '135';
            textBox.dataset.shadowDistance = '5';
            textBox.dataset.shadowOpacity = '1';
            textBox.dataset.isBold = 'false';

            // Create resize handles
            const handles = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];
            handles.forEach(position => {
                const handle = document.createElement('div');
                handle.className = `resize-handle ${position}`;
                handle.contentEditable = 'false';
                handle.addEventListener('mousedown', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    startResize(e, textBox, position);
                });
                textBox.appendChild(handle);
            });

            // Single click to select
            textBox.addEventListener('mousedown', function(e) {
                if (!textBox.classList.contains('editing') && !e.target.classList.contains('resize-handle')) {
                    e.preventDefault();
                    selectTextBox(textBox);
                    isDragging = true;
                    offsetX = e.clientX - textBox.offsetLeft;
                    offsetY = e.clientY - textBox.offsetTop;
                }
            });

            // Double click to edit
            textBox.addEventListener('dblclick', function(e) {
                if (!e.target.classList.contains('resize-handle')) {
                    e.preventDefault();
                    textBox.classList.add('editing');
                    textBox.contentEditable = true;
                    
                    // Reset to auto width when editing starts
                    textBox.style.width = 'auto';
                    textBox.style.height = 'auto';
                    
                    textBox.focus();
                    
                    // Select all text excluding resize handles
                    const range = document.createRange();
                    const selection = window.getSelection();
                    selection.removeAllRanges();
                    
                    // Find first non-handle node
                    const firstNode = Array.from(textBox.childNodes).find(node => 
                        !node.classList || !node.classList.contains('resize-handle')
                    );
                    
                    // Find last non-handle node
                    const lastNode = Array.from(textBox.childNodes).reverse().find(node => 
                        !node.classList || !node.classList.contains('resize-handle')
                    );
                    
                    if (firstNode && lastNode) {
                        range.setStartBefore(firstNode);
                        range.setEndAfter(lastNode);
                        selection.addRange(range);
                    }
                }
            });

            // Handle Enter key to finish editing
            textBox.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && textBox.classList.contains('editing')) {
                    e.preventDefault();
                    textBox.blur();
                }
            });

            // Update HTML code when typing
            textBox.addEventListener('input', function() {
                // Reset width to auto to fit text as user types
                textBox.style.width = 'auto';
                textBox.style.height = 'auto';
                updateHTMLCode();
            });

            // Exit edit mode on blur
            textBox.addEventListener('blur', function() {
                textBox.classList.remove('editing');
                textBox.contentEditable = false;
                
                // Get text content excluding resize handles
                const textContent = Array.from(textBox.childNodes)
                    .filter(node => !node.classList || !node.classList.contains('resize-handle'))
                    .map(node => node.textContent)
                    .join('');
                
                // Ensure resize handles still exist
                const existingHandles = textBox.querySelectorAll('.resize-handle');
                if (existingHandles.length < 4) {
                    // Remove any existing handles
                    existingHandles.forEach(h => h.remove());
                    // Recreate all handles
                    const handlePositions = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];
                    handlePositions.forEach(position => {
                        const handle = document.createElement('div');
                        handle.className = `resize-handle ${position}`;
                        handle.contentEditable = 'false';
                        handle.addEventListener('mousedown', function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            startResize(e, textBox, position);
                        });
                        textBox.appendChild(handle);
                    });
                }
                
                if (textContent.trim() === '') {
                    // Clear all text nodes but keep handles
                    Array.from(textBox.childNodes).forEach(node => {
                        if (!node.classList || !node.classList.contains('resize-handle')) {
                            node.remove();
                        }
                    });
                    // Add placeholder at the beginning
                    const handles = textBox.querySelectorAll('.resize-handle');
                    if (handles.length > 0) {
                        textBox.insertBefore(document.createTextNode('Double-click to edit'), handles[0]);
                    }
                }
                
                // Reset width to auto to fit text
                textBox.style.width = 'auto';
                textBox.style.height = 'auto';
                
                updateHTMLCode();
            });

            leftSection.appendChild(textBox);
            selectTextBox(textBox);
            updateHTMLCode();
        }

        function selectTextBox(textBox) {
            if (selectedTextBox) {
                selectedTextBox.classList.remove('selected');
            }
            selectedTextBox = textBox;
            textBox.classList.add('selected');
            
            // Update color picker to match selected text
            const solidColor = textBox.dataset.solidColor || '#000000';
            const gradientColor1 = textBox.dataset.gradientColor1 || solidColor;
            const gradientColor2 = textBox.dataset.gradientColor2 || '#000000';
            const hasGradient = textBox.dataset.gradientEnabled === 'true';
            const gradientType = textBox.dataset.gradientType || 'linear';
            
            document.getElementById('colorInput').value = gradientColor1;
            document.getElementById('gradientColorInput').value = gradientColor2;
            document.getElementById('gradientTypeSelect').value = gradientType;
            
            // Update font selector
            const fontFamily = textBox.dataset.fontFamily || 'Arial';
            document.getElementById('fontSelect').value = fontFamily;
            
            // Update outline button and controls
            const hasOutline = textBox.dataset.outlineEnabled === 'true';
            const outlineColor = textBox.dataset.outlineColor || '#000000';
            
            const toggleOutlineButton = document.getElementById('toggleOutlineButton');
            const outlineControls = document.getElementById('outlineControls');
            
            if (hasOutline) {
                outlineEnabled = true;
                toggleOutlineButton.textContent = '-';
                outlineControls.classList.add('visible');
                document.getElementById('outlineColorInput').value = outlineColor;
            } else {
                outlineEnabled = false;
                toggleOutlineButton.textContent = 'O';
                outlineControls.classList.remove('visible');
            }
            
            updateOutlineColorCircle();
            
            // Update transparency slider
            const opacity = textBox.dataset.opacity || '1';
            document.getElementById('transparencySlider').value = opacity;
            
            // Update shadow button and state
            const hasShadow = textBox.dataset.shadowEnabled === 'true';
            const toggleShadowButton = document.getElementById('toggleShadowButton');
            const shadowEditButton = document.getElementById('shadowEditButton');
            
            if (hasShadow) {
                shadowEnabled = true;
                toggleShadowButton.textContent = '-';
                shadowEditButton.classList.add('visible');
                
                // Load shadow properties
                shadowAngle = parseInt(textBox.dataset.shadowAngle) || 135;
                shadowDistance = parseFloat(textBox.dataset.shadowDistance) || 5;
                shadowOpacity = parseFloat(textBox.dataset.shadowOpacity) || 1;
                
                document.getElementById('shadowOpacitySlider').value = shadowOpacity;
                document.getElementById('shadowDistanceSlider').value = shadowDistance;
                document.getElementById('shadowCompassLine').style.transform = `translate(-50%, -100%) rotate(${shadowAngle}deg)`;
            } else {
                shadowEnabled = false;
                toggleShadowButton.textContent = 'S';
                shadowEditButton.classList.remove('visible');
                document.getElementById('shadowEditorPopup').classList.remove('visible');
            }
            
            // Update bold button
            const isBold = textBox.dataset.isBold === 'true';
            const toggleBoldButton = document.getElementById('toggleBoldButton');
            if (isBold) {
                toggleBoldButton.classList.add('active');
            } else {
                toggleBoldButton.classList.remove('active');
            }
            
            // Update gradient button and controls
            const toggleButton = document.getElementById('toggleGradientButton');
            const gradientControls = document.getElementById('gradientControls');
            
            if (hasGradient) {
                gradientEnabled = true;
                toggleButton.textContent = '-';
                gradientControls.classList.add('visible');
                
                // Load gradient angle
                gradientAngle = parseInt(textBox.dataset.gradientAngle) || 90;
                const compassLine = document.getElementById('compassLine');
                compassLine.style.transform = `translate(-50%, -100%) rotate(${gradientAngle}deg)`;
            } else {
                gradientEnabled = false;
                toggleButton.textContent = '+';
                gradientControls.classList.remove('visible');
            }
            
            updateColorCircle();
            showBottomBar();
        }

        function startResize(e, textBox, position) {
            isResizing = true;
            currentResizeHandle = position;
            startX = e.clientX;
            startY = e.clientY;
            startWidth = textBox.offsetWidth;
            startHeight = textBox.offsetHeight;
            startLeft = textBox.offsetLeft;
            startTop = textBox.offsetTop;
            startFontSize = parseFloat(window.getComputedStyle(textBox).fontSize);
        }

        // Mouse move for dragging and resizing
        document.addEventListener('mousemove', function(e) {
            if (isResizing && selectedTextBox) {
                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;

                if (currentResizeHandle === 'bottom-right') {
                    const newWidth = Math.max(50, startWidth + deltaX);
                    selectedTextBox.style.width = newWidth + 'px';
                    selectedTextBox.style.height = Math.max(20, startHeight + deltaY) + 'px';
                    // Scale font size based on width change
                    const scale = newWidth / startWidth;
                    selectedTextBox.style.fontSize = (startFontSize * scale) + 'px';
                } else if (currentResizeHandle === 'bottom-left') {
                    const newWidth = Math.max(50, startWidth - deltaX);
                    selectedTextBox.style.width = newWidth + 'px';
                    selectedTextBox.style.left = (startLeft + (startWidth - newWidth)) + 'px';
                    selectedTextBox.style.height = Math.max(20, startHeight + deltaY) + 'px';
                    // Scale font size
                    const scale = newWidth / startWidth;
                    selectedTextBox.style.fontSize = (startFontSize * scale) + 'px';
                } else if (currentResizeHandle === 'top-right') {
                    const newWidth = Math.max(50, startWidth + deltaX);
                    selectedTextBox.style.width = newWidth + 'px';
                    const newHeight = Math.max(20, startHeight - deltaY);
                    selectedTextBox.style.height = newHeight + 'px';
                    selectedTextBox.style.top = (startTop + (startHeight - newHeight)) + 'px';
                    // Scale font size
                    const scale = newWidth / startWidth;
                    selectedTextBox.style.fontSize = (startFontSize * scale) + 'px';
                } else if (currentResizeHandle === 'top-left') {
                    const newWidth = Math.max(50, startWidth - deltaX);
                    const newHeight = Math.max(20, startHeight - deltaY);
                    selectedTextBox.style.width = newWidth + 'px';
                    selectedTextBox.style.height = newHeight + 'px';
                    selectedTextBox.style.left = (startLeft + (startWidth - newWidth)) + 'px';
                    selectedTextBox.style.top = (startTop + (startHeight - newHeight)) + 'px';
                    // Scale font size
                    const scale = newWidth / startWidth;
                    selectedTextBox.style.fontSize = (startFontSize * scale) + 'px';
                }
            } else if (isDragging && selectedTextBox && !selectedTextBox.classList.contains('editing')) {
                const leftSection = document.getElementById('leftSection');
                const rect = leftSection.getBoundingClientRect();
                
                let newX = e.clientX - offsetX;
                let newY = e.clientY - offsetY;
                
                // Keep within bounds
                newX = Math.max(0, Math.min(newX, rect.width - selectedTextBox.offsetWidth));
                newY = Math.max(0, Math.min(newY, rect.height - selectedTextBox.offsetHeight));
                
                selectedTextBox.style.left = newX + 'px';
                selectedTextBox.style.top = newY + 'px';
            }
        });

        // Mouse up to stop dragging/resizing
        document.addEventListener('mouseup', function() {
            if (isDragging || isResizing) {
                updateHTMLCode();
            }
            isDragging = false;
            isResizing = false;
            currentResizeHandle = null;
        });

        // Deselect when clicking on blank area
        document.getElementById('leftSection').addEventListener('mousedown', function(e) {
            // Check if the click is on the left section itself (not on a text box or bottom bar)
            if (e.target === this && selectedTextBox) {
                selectedTextBox.classList.remove('selected');
                selectedTextBox = null;
                updateColorCircle();
                showBottomBar();
            }
        });

        // Delete on backspace
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Backspace' && selectedTextBox && !selectedTextBox.classList.contains('editing')) {
                e.preventDefault();
                selectedTextBox.remove();
                selectedTextBox = null;
                updateColorCircle();
                showBottomBar();
                updateHTMLCode();
            }
        });
    </script>
</body>
</html>
